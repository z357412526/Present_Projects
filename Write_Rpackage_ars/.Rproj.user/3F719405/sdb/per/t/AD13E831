{
    "contents" : "#' Adapative Rejection Sampling\n#'\n#' Adapative rejection sampling from log-concave functions. See Gilks and Wild (1992) for more details.\n#' @param N sample size (or number of observations).\n#' @param f function f(x) which is log-concave and is proporitional to the density you wish to sample from\n#' @param a first starting point for which f(x) is defined. The default is Inf.\n#' @param b second starting pointfor which f(x) is defined. The default is -Inf.\n#' @param DFUN the derivative of f(x)\n#' @param step value of bandwidth around est_mode used to initialize function. The default is 0.5.\n#' @param est_mod estimated mode of f(x) after log if f(x) is unbounded. The default is 0.\n#' @return \\code{ars} returns a list containing the following components:\n#' \\item{f}{f(x)}\n#' \\item{fprime}{the derivative of f(x)}\n#' \\item{sample}{a vector of length N containing sampled values}\n#' \\item{hit_rate}{a value giving the proportion of accepted sample values over all evaluated values}\n#' @author \n#' Code developed by Xinyue Zhou, Cenzhuo Yao, Katherine C. Ullman, and Lauren Catherine Ponisio, based on Gilks and Wild (1992).\n#' @references \n#' Gilks, W.R., P. Wild. (1992) Adaptive Rejection Sampling for Gibbs Sampling, Applied Statistics 41:337â€“348. \n#' @export\n#' @examples \n#' # Example 1: Sample from Standard Normal Distribution\n#' library(ars)\n#'  N <- 1000\n#'  x <- seq(-5, 5, len = N)\n#'  dnor <- function(x) {\n#'    return((1/(sqrt(2*pi)))*exp(-(x^2)/2))\n#'  }\n#'  out.norm <- ars(N=N, f=dnor, a=-5, b=5)\n#'  plot(density(out.norm$sample), type=\"l\", col=\"dodgerblue\", lwd=2,\n#'       main=\"Normal distribution\", xlab=\"\")\n#'  y <- dnorm(x)\n#'  points(x, y, type = \"l\", lwd=2)\n#' # Example 2 : Sample from Laplace Distribution\n#'  x <- seq(-5, 5, len = N)\n#'  dlaplace <- function(x, m = 0, s = 1) {\n#'  return(exp(-abs(x-m)/s)/(2*s))\n#'  }\n#' out.lap <- ars(N=N, f= dlaplace, a=-5, b=5)\n#' plot(density(out.lap$sample), type=\"l\", col=\"dodgerblue\", lwd=2,\n#'     main=\"Laplace distribution\", xlab=\"\")\n#' y <- dlaplace(x, m=0, s=1)\n#' points(x, y, type = \"l\")\n\n## main function to implement adaptive rejection algorithm\n## Input\n## N - number: the number of desired samples\n## f - function: the density function users interested in\n## a, b - number: the optional starting values\n## DFUN - function: the optional fprime\n## step - number: value of bandwidth around est_mode used to initialize function, optional.\n## est_mod - number: estimated mode of f(x) after log if f(x) is unbounded, optional.\n\n## Output - list\n## f - function: the density function users interested in\n## fprime - function: fprime we finally used\n## sample - vector: the samples drawn from the interested density function\n## hit_rate - number: a value giving the proportion of accepted sample values over all evaluated values\n\nars <- function(N, f,\n                a = -Inf,\n                b = Inf,\n                DFUN = NA,\n                step = 0.5,\n                est_mod = 0){\n  ## check if it is unbounded or not \n  if(class(f) != \"function\"){\n    stop('please provide f as an function', call. = FALSE)\n  }\n  if(!is.na(DFUN)){\n    if(class(DFUN) != \"function\"){\n      warning('DFUN is not an function, re-creating from FUN',\n              call. = FALSE, immediate.= TRUE)\n      DFUN <- NA\n    }\n  }\n  if(a == b){\n    stop('please provide different a and b', call. = FALSE)\n  }\n  \n  ##log of density function: right now, users can input density function\n  FUN <- function(x,fun = f){\n    return(log(fun(x)))\n  }\n  ##differentiate it using the function we define\n  Derv_final <- function(x,fun=FUN){\n    return(Derv(x,fun,a,b))\n  }\n  \n  if(!is.na(DFUN)){\n    DD<- DFUN\n  } else{\n    DD <- Derv_final\n  }\n  \n  \n  ## initial return sample\n  ret <- rep(NA, N)\n  ##count step\n  count <- 0 \n  info <- matrix(NA, nrow = as.integer((N^(1/3) + 2)),\n                 ncol = 3)\n  z <- c(NA, rep(NA, as.integer((N^(1/3) + 2))))\n  ## matrix for x, f, fprime values, initialize at the expected length\n  ## from Gilks et al. 1992 with a little extra\n  ## how to initialize the info matrix\n  if (a != -Inf && b != Inf){\n    info <- help_init_info(a, b, info, FUN, DD)\n    z <- init_z(x_star, a, b, info, z)\n    ## for uniform case:\n    if ((abs(info[2, 3]) < 1e-6)&&(abs(info[1, 3])< 1e-6)){\n      return (list(f = FUN,\n                   fprime = DD,\n                   sample = runif(n=N ,a, b),\n                   info = info[1:2,]))\n    }\n  } \n  \n  if (a == -Inf && b != Inf){\n    ## if est_mod out of the support, then\n    if (est_mod > b) {\n      est_mod <- b - step\n    }\n    aa <- est_mod\n    test <- DD(est_mod)\n    while (-Inf < test && test <= 0 && count <=50){\n      aa <- aa - step\n      test <- DD(aa)\n      count = count + 1\n    }\n    info <- help_init_info(aa, b, info, FUN, DD)\n    z <- init_z(x_star, a, b, info, z)\n  }\n  \n  \n  if (a != -Inf && b == Inf){\n    if (est_mod < a) { \n      est_mod = a + step\n    }\n    bb <- est_mod\n    test <- DD(bb)\n    while (0 <=  test && test < Inf && count <=50){\n      bb <- bb + step\n      test <- DD(bb)\n      count = count + 1\n    }\n    info <- help_init_info(a, bb, info, FUN, DD)\n    z <- init_z(x_star, a, b, info, z)\n  }\n  \n  if (a == -Inf && b == Inf){\n    aa <- est_mod - step \n    bb <- est_mod + step\n    test1 <- DD(aa)\n    test2 <- DD(bb)\n    while (-Inf < test1 && test1 <= 0 && count <= 50 ){\n      aa <- aa - step\n      test1 <- DD(aa)\n      count = count + 1\n    }\n    while (0 <=  test2 && test2 < Inf && count <= 100){\n      bb <- bb + step\n      test <- DD(bb)\n      count = count + 1\n    }\n    info <- help_init_info(aa, bb, info, FUN, DD)\n    z <- init_z(x_star, a, b, info, z)\n  }\n  \n  if (count >= 50) {\n    stop (\"est_mod is not valid, initial point cannot be found. Try another est_mod\",.call = FALSE)\n  }\n  \n  ## starting index\n  itt1 <- 3\n  itt2 <- 4\n  sample <- it <- 0\n  num_sample <- 1\n  \n  ## sample step\n  while(sample < N){\n    it <- it + num_sample\n    hit_rate <- 1 - (itt1 - 3)/it\n    clean_info <- info[1:(itt1-1),]\n    ## check log-concavity of f(x)\n    if(!check_concave(clean_info)) {\n      stop('Input is not log-concave function', call. = FALSE)\n    }\n    clean_z <- z[1:(itt2-1)]\n    ##sample!!!\n    if (hit_rate == 1) {\n      num_sample <- 1\n    } else {\n      num_sample <- round(1/(1-hit_rate), digits = 0)}\n    \n    x <- sample_envelope(clean_info, clean_z, num_sample)\n    ##print(x)\n    ## check if x is defined on fx\n    test_fx <- FUN(x)\n    ## draw a new x if not\n    if(sum(!is.finite(test_fx))) next\n    ## check if this value of x have been drawn before. If that is the\n    ## case, we can directly throw it into the info matrix or sample\n    \n    ## get the corresponding point on upper bound of lower bound\n    ## whether we reject the sample\n    w <- runif(num_sample)\n    for (i in 1:num_sample){\n      ind1 <- rev(which(clean_info[ ,1] < x[i]))[1]\n      ind2 <- which(clean_info[ ,1] > x[i])[1]\n      if ((is.na(ind1) || is.na(ind2))&& is.finite(a) && is.finite(b)) {\n        next\n      }\n      \n      ## calculate lower bound\n      if (is.na(ind1) || is.na(ind2)) {\n        lx <- -Inf\n      } else {\n        lx <- line_fun(clean_info[ind1, 1],\n                       clean_info[ind1, 2],\n                       clean_info[ind2, 1],\n                       clean_info[ind2, 2], x[i])\n      }\n      if (is.na(ind1)){\n        ux <- line_fun_p(clean_info[ind2, 1],\n                         clean_info[ind2, 2],\n                         clean_info[ind2, 3], x[i])\n      } else {\n        if(x[i] <= clean_z[ind1 + 1]){\n          ux <- line_fun_p(clean_info[ind1, 1],\n                           clean_info[ind1, 2],\n                           clean_info[ind1, 3], x[i])\n        } else{\n          ux <- line_fun_p(clean_info[ind2, 1],\n                           clean_info[ind2, 2],\n                           clean_info[ind2, 3], x[i])\n        } \n      }\n      \n      ## reject/accept sample\n      if(w[i] <= exp(lx - ux)) {\n        sample <- sample + 1\n        ret[sample] <- x[i] \n        next\n      } else{\n        if(w[i] <= exp(test_fx[i] - ux)){\n          sample <- sample + 1\n          ret[sample] <- x[i]\n        }\n        info <- update_info(x[i], info, itt1, FUN, test_fx[i],\n                            DD,\n                            num_sample)\n        itt1 <- itt1 + 1\n        z <- update_z(x[i], z, itt2, info[1:(itt1-1), ])\n        itt2 <- itt2 + 1\n      } \n    }\n  }\n  ## return sample\n  hit_rate <- length(ret)/it\n  return(list(f=FUN,\n              fprime=DD,\n              sample = ret,\n              hit_rate = 1 - (itt1 - 3)/it))\n}",
    "created" : 1450313803196.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2634928538",
    "id" : "AD13E831",
    "lastKnownWriteTime" : 1450315660,
    "path" : "~/final_proj243/ars/R/ars.R",
    "project_path" : "R/ars.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}